//! AWS IAM authentication support for Redis
//!
//! This module provides token-based authentication using AWS IAM,
//! enabling secure, dynamic authentication for ElastiCache and MemoryDB
//! connections with automatic token refresh and streaming credentials support.
//!
//! # Overview
//!
//! AWS IAM authentication allows you to authenticate to Redis using IAM credentials
//! instead of static passwords. This is supported by Amazon ElastiCache and Amazon
//! MemoryDB. Tokens are generated by creating a presigned SigV4 request and are
//! valid for 15 minutes.
//!
//! # Features
//!
//! - **Automatic Token Refresh & Streaming of Credentials**: Seamlessly handle token
//!   expiration and stream updated credentials to prevent connection errors
//! - **Multiple Credential Sources**: Bring your own `ProvideCredentials` implementation
//!   or use the default credentials chain from the environment
//! - **Configurable Refresh Policies**: Customizable retry behavior via [`RetryConfig`]
//! - **Async-First Design**: Full async/await support for non-blocking operations
//!
//! # Quick Start
//!
//! ## Enable the Feature
//!
//! Add the `aws-iam` feature to your `Cargo.toml`.
//!
//! ## Basic Usage with Environment Credentials
//!
//! ```rust,no_run
//! use redis::{Client, AwsIamCredentialsProvider, AwsRedisServiceName, RetryConfig};
//!
//! # async fn example() -> redis::RedisResult<()> {
//! // Create the credentials provider using default credentials chain
//! let mut provider = AwsIamCredentialsProvider::new_from_env(
//!     "my-user-id".to_string(),
//!     "my-cluster.abc123.use1.cache.amazonaws.com".to_string(),
//!     "us-east-1".to_string(),
//!     AwsRedisServiceName::ElastiCache,
//! ).await?;
//! provider.start(RetryConfig::default());
//!
//! // Create Redis client with credentials provider
//! let client = Client::open_with_credentials_provider(
//!     "rediss://my-cluster.abc123.use1.cache.amazonaws.com:6379",
//!     provider,
//! )?;
//!
//! // Use the client to get a multiplexed connection
//! let mut con = client.get_multiplexed_async_connection().await?;
//! redis::cmd("SET")
//!     .arg("my_key")
//!     .arg(42i32)
//!     .exec_async(&mut con)
//!     .await?;
//! # Ok(())
//! # }
//! ```
//!
//! [`Client`]: crate::Client
//! [`StreamingCredentialsProvider`]: crate::auth::StreamingCredentialsProvider

use crate::RetryConfig;
use crate::auth::BasicAuth;
use crate::auth::StreamingCredentialsProvider;
use crate::auth_management::credentials_management_utils;
use crate::errors::{ErrorKind, RedisError};
use crate::types::RedisResult;
use aws_credential_types::provider::{ProvideCredentials, SharedCredentialsProvider};
use aws_sigv4::http_request::{SignableBody, SignableRequest, SignatureLocation, sign};
use aws_sigv4::sign::v4;
use aws_smithy_runtime_api::client::identity::Identity;
use futures_util::{Stream, StreamExt};
use log::{debug, error, warn};
use std::pin::Pin;
use std::sync::{Arc, Mutex, RwLock};
use std::time::{Duration, SystemTime};
use tokio::sync::mpsc::Sender;

/// The lifetime of an AWS IAM auth token in seconds (15 minutes).
const TOKEN_LIFETIME_SECS: u64 = 900;

/// The ratio of token lifetime at which to trigger a refresh.
/// 0.8 of 900s = 720s = 12 minutes.
const TOKEN_REFRESH_RATIO: f64 = 0.8;

/// The AWS Redis service name, used for SigV4 signing.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum AwsRedisServiceName {
    /// Amazon ElastiCache
    ElastiCache,
    /// Amazon MemoryDB
    MemoryDB,
}

impl AwsRedisServiceName {
    /// Returns the service name string used for SigV4 signing.
    pub fn as_str(&self) -> &str {
        match self {
            Self::ElastiCache => "elasticache",
            Self::MemoryDB => "memorydb",
        }
    }
}

type Subscriptions = Vec<Sender<RedisResult<BasicAuth>>>;
type SharedSubscriptions = Arc<Mutex<Subscriptions>>;

/// AWS IAM credentials provider for ElastiCache and MemoryDB authentication.
///
/// This provider generates IAM auth tokens by creating presigned SigV4 requests
/// and implements [`StreamingCredentialsProvider`] to support automatic token
/// refresh for multiplexed connections.
#[derive(Clone)]
pub struct AwsIamCredentialsProvider {
    credentials_provider: SharedCredentialsProvider,
    user_id: String,
    host_name: String,
    region: String,
    service_name: AwsRedisServiceName,
    is_serverless: bool,
    background_handle: Arc<Mutex<Option<tokio::task::JoinHandle<()>>>>,
    subscribers: SharedSubscriptions,
    current_credentials: Arc<RwLock<Option<BasicAuth>>>,
}

impl AwsIamCredentialsProvider {
    /// Create a new provider with a custom AWS credentials provider.
    ///
    /// # Arguments
    ///
    /// * `user_id` - The ElastiCache/MemoryDB user ID to authenticate as
    /// * `host_name` - The Redis cluster endpoint hostname
    /// * `region` - The AWS region (e.g., "us-east-1")
    /// * `service_name` - The AWS service (ElastiCache or MemoryDB)
    /// * `credentials_provider` - An AWS credentials provider
    pub fn new(
        user_id: String,
        host_name: String,
        region: String,
        service_name: AwsRedisServiceName,
        credentials_provider: impl aws_credential_types::provider::ProvideCredentials + 'static,
    ) -> Self {
        Self {
            credentials_provider: SharedCredentialsProvider::new(credentials_provider),
            user_id,
            host_name,
            region,
            service_name,
            is_serverless: false,
            background_handle: Default::default(),
            subscribers: Default::default(),
            current_credentials: Default::default(),
        }
    }

    /// Create a new provider using the default AWS credentials chain from the environment.
    ///
    /// This is async because the default credentials chain may need to make network
    /// calls (e.g., to IMDS or ECS metadata service) during initialization.
    ///
    /// # Arguments
    ///
    /// * `user_id` - The ElastiCache/MemoryDB user ID to authenticate as
    /// * `host_name` - The Redis cluster endpoint hostname
    /// * `region` - The AWS region (e.g., "us-east-1")
    /// * `service_name` - The AWS service (ElastiCache or MemoryDB)
    pub async fn new_from_env(
        user_id: String,
        host_name: String,
        region: String,
        service_name: AwsRedisServiceName,
    ) -> RedisResult<Self> {
        let config = aws_config::defaults(aws_config::BehaviorVersion::latest())
            .region(aws_config::Region::new(region.clone()))
            .load()
            .await;

        let credentials_provider = config.credentials_provider().ok_or_else(|| {
            RedisError::from((
                ErrorKind::AuthenticationFailed,
                "No AWS credentials provider found in environment",
            ))
        })?;

        Ok(Self {
            credentials_provider: SharedCredentialsProvider::new(credentials_provider),
            user_id,
            host_name,
            region,
            service_name,
            is_serverless: false,
            background_handle: Default::default(),
            subscribers: Default::default(),
            current_credentials: Default::default(),
        })
    }

    /// Set whether the target is a serverless cache.
    ///
    /// When `true`, the `ResourceType=ServerlessCache` parameter is added to the
    /// presigned URL. Defaults to `false`.
    pub fn set_serverless(&mut self, is_serverless: bool) {
        self.is_serverless = is_serverless;
    }

    /// Generate an IAM auth token by creating a presigned SigV4 URL.
    async fn generate_auth_token(&self) -> RedisResult<String> {
        // 1. Resolve credentials from provider
        let creds: aws_credential_types::Credentials = self
            .credentials_provider
            .provide_credentials()
            .await
            .map_err(|e| {
                RedisError::from((
                    ErrorKind::AuthenticationFailed,
                    "AWS IAM credentials resolution failed",
                    format!("{e}"),
                ))
            })?;
        let identity: Identity = creds.into();

        // 2. Build unsigned URL
        let mut url = format!(
            "http://{}/?Action=connect&User={}",
            self.host_name, self.user_id
        );
        if self.is_serverless {
            url.push_str("&ResourceType=ServerlessCache");
        }

        // 3. Configure SigV4 presigning
        let mut settings = aws_sigv4::http_request::SigningSettings::default();
        settings.signature_location = SignatureLocation::QueryParams;
        settings.expires_in = Some(Duration::from_secs(TOKEN_LIFETIME_SECS));

        let signing_params = v4::SigningParams::builder()
            .identity(&identity)
            .region(&self.region)
            .name(self.service_name.as_str())
            .time(SystemTime::now())
            .settings(settings)
            .build()
            .map_err(|e| {
                RedisError::from((
                    ErrorKind::AuthenticationFailed,
                    "Failed to build SigV4 signing params",
                    format!("{e}"),
                ))
            })?
            .into();

        // 4. Sign the request
        let signable_request = SignableRequest::new(
            "GET",
            &url,
            std::iter::empty(),
            SignableBody::UnsignedPayload,
        )
        .map_err(|e| {
            RedisError::from((
                ErrorKind::AuthenticationFailed,
                "Failed to create signable request",
                format!("{e}"),
            ))
        })?;

        let (signing_instructions, _signature) = sign(signable_request, &signing_params)
            .map_err(|e| {
                RedisError::from((
                    ErrorKind::AuthenticationFailed,
                    "SigV4 signing failed",
                    format!("{e}"),
                ))
            })?
            .into_parts();

        // 5. Apply signing instructions and extract the signed URL
        let mut request = http::Request::builder()
            .uri(&url)
            .method("GET")
            .body(())
            .expect("failed to build http request");
        signing_instructions.apply_to_request_http1x(&mut request);

        let signed_url = request.uri().to_string();
        Ok(signed_url
            .strip_prefix("http://")
            .unwrap_or(&signed_url)
            .to_string())
    }

    async fn notify_subscribers(
        subscribers_arc: &SharedSubscriptions,
        credentials_result: &RedisResult<BasicAuth>,
    ) {
        let subscribers = {
            let mut guard = subscribers_arc
                .lock()
                .expect("could not acquire lock for subscribers");
            guard.retain(|sender| !sender.is_closed());
            guard.clone()
        };

        futures_util::future::join_all(subscribers.iter().map(|sender| {
            let response = credentials_result.clone();
            sender.send(response)
        }))
        .await;
    }

    /// Start the background token refresh service.
    ///
    /// This spawns a tokio task that periodically generates new auth tokens
    /// and pushes them to all subscribers. Tokens are refreshed at 80% of their
    /// 15-minute lifetime (i.e., every 12 minutes).
    pub fn start(&mut self, retry_config: RetryConfig) {
        // Prevent multiple calls to start
        if self.background_handle.lock().unwrap().is_some() {
            return;
        }

        let subscribers_arc = Arc::clone(&self.subscribers);
        let current_credentials_arc = Arc::clone(&self.current_credentials);
        let provider = self.clone();

        *self.background_handle.lock().unwrap() = Some(tokio::spawn(async move {
            let refresh_interval = Duration::from_secs_f64(
                TOKEN_LIFETIME_SECS as f64 * TOKEN_REFRESH_RATIO,
            );
            let mut attempt = 0;
            let mut error_delay = retry_config.initial_delay;

            loop {
                debug!("Refreshing AWS IAM auth token. Attempt {attempt}");
                let token_result = provider.generate_auth_token().await;

                match token_result {
                    Ok(token) => {
                        attempt = 0;
                        error_delay = retry_config.initial_delay;

                        let credentials = BasicAuth {
                            username: provider.user_id.clone(),
                            password: token,
                        };

                        *current_credentials_arc.write().unwrap() = Some(credentials.clone());

                        let result: RedisResult<BasicAuth> = Ok(credentials);
                        Self::notify_subscribers(&subscribers_arc, &result).await;

                        tokio::time::sleep(refresh_interval).await;
                    }
                    Err(err) => {
                        attempt += 1;
                        if attempt < retry_config.max_attempts {
                            error_delay = credentials_management_utils::calculate_next_delay(
                                error_delay,
                                retry_config.backoff_multiplier,
                                retry_config.max_delay,
                            );
                            warn!(
                                "An error occurred while refreshing the AWS IAM auth token. Attempt {attempt}. Sleeping for {:?}",
                                error_delay
                            );
                            tokio::time::sleep(error_delay).await;
                            continue;
                        }
                        error!("Maximum token refresh attempts reached. Stopping token refresh.");
                        let result: RedisResult<BasicAuth> = Err(err);
                        Self::notify_subscribers(&subscribers_arc, &result).await;
                        break;
                    }
                }
            }
        }));
    }

    /// Stop the background refresh service.
    fn stop(&mut self) {
        if let Some(handle) = self.background_handle.lock().unwrap().take() {
            handle.abort();
        }
    }
}

impl StreamingCredentialsProvider for AwsIamCredentialsProvider {
    fn subscribe(&self) -> Pin<Box<dyn Stream<Item = RedisResult<BasicAuth>> + Send + 'static>> {
        let (tx, rx) = tokio::sync::mpsc::channel::<RedisResult<BasicAuth>>(1);

        self.subscribers
            .lock()
            .expect("could not acquire lock for subscribers")
            .push(tx);

        let stream = futures_util::stream::unfold(rx, |mut rx| async move {
            rx.recv().await.map(|item| (item, rx))
        });

        if let Some(creds) = self.current_credentials.read().unwrap().clone() {
            futures_util::stream::once(async move { Ok(creds) })
                .chain(stream)
                .boxed()
        } else {
            stream.boxed()
        }
    }
}

impl std::fmt::Debug for AwsIamCredentialsProvider {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("AwsIamCredentialsProvider")
            .field("user_id", &self.user_id)
            .field("host_name", &self.host_name)
            .field("region", &self.region)
            .field("service_name", &self.service_name)
            .field("is_serverless", &self.is_serverless)
            .field("credentials_provider", &"<SharedCredentialsProvider>")
            .finish()
    }
}

impl Drop for AwsIamCredentialsProvider {
    fn drop(&mut self) {
        self.stop();
    }
}

#[cfg(all(feature = "aws-iam", test))]
mod tests {
    use super::*;

    #[test]
    fn test_aws_redis_service_name() {
        assert_eq!(AwsRedisServiceName::ElastiCache.as_str(), "elasticache");
        assert_eq!(AwsRedisServiceName::MemoryDB.as_str(), "memorydb");
    }

    #[test]
    fn test_provider_debug() {
        use aws_credential_types::Credentials;
        let creds = Credentials::new("AKID", "SECRET", None, None, "test");
        let provider = AwsIamCredentialsProvider::new(
            "my-user".to_string(),
            "my-host.cache.amazonaws.com".to_string(),
            "us-east-1".to_string(),
            AwsRedisServiceName::ElastiCache,
            creds,
        );
        let debug_str = format!("{:?}", provider);
        assert!(debug_str.contains("AwsIamCredentialsProvider"));
        assert!(debug_str.contains("my-user"));
        assert!(debug_str.contains("us-east-1"));
        assert!(!debug_str.contains("SECRET"));
    }

    #[test]
    fn test_set_serverless() {
        use aws_credential_types::Credentials;
        let creds = Credentials::new("AKID", "SECRET", None, None, "test");
        let mut provider = AwsIamCredentialsProvider::new(
            "my-user".to_string(),
            "my-host.cache.amazonaws.com".to_string(),
            "us-east-1".to_string(),
            AwsRedisServiceName::ElastiCache,
            creds,
        );
        assert!(!provider.is_serverless);
        provider.set_serverless(true);
        assert!(provider.is_serverless);
    }

    #[tokio::test]
    async fn test_generate_auth_token() {
        use aws_credential_types::Credentials;
        let creds = Credentials::new("AKIAIOSFODNN7EXAMPLE", "SECRET", None, None, "test");
        let provider = AwsIamCredentialsProvider::new(
            "my-user".to_string(),
            "my-cluster.abc123.use1.cache.amazonaws.com".to_string(),
            "us-east-1".to_string(),
            AwsRedisServiceName::ElastiCache,
            creds,
        );

        let token = provider.generate_auth_token().await.unwrap();

        // Token should not have the http:// prefix
        assert!(!token.starts_with("http://"));
        // Token should contain the hostname
        assert!(token.contains("my-cluster.abc123.use1.cache.amazonaws.com"));
        // Token should contain the Action and User params
        assert!(token.contains("Action=connect"));
        assert!(token.contains("User=my-user"));
        // Token should contain SigV4 query parameters
        assert!(token.contains("X-Amz-Signature="));
        assert!(token.contains("X-Amz-Credential="));
    }

    #[tokio::test]
    async fn test_generate_auth_token_serverless() {
        use aws_credential_types::Credentials;
        let creds = Credentials::new("AKIAIOSFODNN7EXAMPLE", "SECRET", None, None, "test");
        let mut provider = AwsIamCredentialsProvider::new(
            "my-user".to_string(),
            "my-cluster.abc123.use1.cache.amazonaws.com".to_string(),
            "us-east-1".to_string(),
            AwsRedisServiceName::ElastiCache,
            creds,
        );
        provider.set_serverless(true);

        let token = provider.generate_auth_token().await.unwrap();
        assert!(token.contains("ResourceType=ServerlessCache"));
    }

    #[tokio::test]
    async fn test_generate_auth_token_memorydb() {
        use aws_credential_types::Credentials;
        let creds = Credentials::new("AKIAIOSFODNN7EXAMPLE", "SECRET", None, None, "test");
        let provider = AwsIamCredentialsProvider::new(
            "my-user".to_string(),
            "my-cluster.abc123.memorydb.us-east-1.amazonaws.com".to_string(),
            "us-east-1".to_string(),
            AwsRedisServiceName::MemoryDB,
            creds,
        );

        let token = provider.generate_auth_token().await.unwrap();
        assert!(token.contains("my-cluster.abc123.memorydb.us-east-1.amazonaws.com"));
        assert!(token.contains("Action=connect"));
    }

    #[tokio::test]
    async fn test_streaming_credentials_with_background_refresh() {
        use aws_credential_types::Credentials;
        let creds = Credentials::new("AKIAIOSFODNN7EXAMPLE", "SECRET", None, None, "test");
        let mut provider = AwsIamCredentialsProvider::new(
            "my-user".to_string(),
            "my-cluster.abc123.use1.cache.amazonaws.com".to_string(),
            "us-east-1".to_string(),
            AwsRedisServiceName::ElastiCache,
            creds,
        );

        provider.start(RetryConfig::default());

        // Wait for the background task to generate the first token
        tokio::time::sleep(Duration::from_millis(200)).await;

        let mut stream = provider.subscribe();
        let credentials = stream.next().await.unwrap().unwrap();
        assert_eq!(credentials.username, "my-user");
        assert!(!credentials.password.is_empty());
        assert!(credentials.password.contains("X-Amz-Signature="));
    }

    #[tokio::test]
    async fn test_multiple_subscribers() {
        use aws_credential_types::Credentials;
        let creds = Credentials::new("AKIAIOSFODNN7EXAMPLE", "SECRET", None, None, "test");
        let mut provider = AwsIamCredentialsProvider::new(
            "my-user".to_string(),
            "my-cluster.abc123.use1.cache.amazonaws.com".to_string(),
            "us-east-1".to_string(),
            AwsRedisServiceName::ElastiCache,
            creds,
        );

        provider.start(RetryConfig::default());

        // Wait for initial token
        tokio::time::sleep(Duration::from_millis(200)).await;

        let mut stream1 = provider.subscribe();
        let mut stream2 = provider.subscribe();

        let creds1 = stream1.next().await.unwrap().unwrap();
        let creds2 = stream2.next().await.unwrap().unwrap();

        // Both should get the same cached credentials
        assert_eq!(creds1.username, creds2.username);
        assert_eq!(creds1.password, creds2.password);
    }

    #[tokio::test]
    async fn test_provider_cleanup() {
        use aws_credential_types::Credentials;
        let creds = Credentials::new("AKIAIOSFODNN7EXAMPLE", "SECRET", None, None, "test");
        let mut provider = AwsIamCredentialsProvider::new(
            "my-user".to_string(),
            "my-cluster.abc123.use1.cache.amazonaws.com".to_string(),
            "us-east-1".to_string(),
            AwsRedisServiceName::ElastiCache,
            creds,
        );

        provider.start(RetryConfig::default());
        tokio::time::sleep(Duration::from_millis(100)).await;
        drop(provider);
        tokio::time::sleep(Duration::from_millis(50)).await;
        // Test passes if no panic occurs during cleanup
    }
}
